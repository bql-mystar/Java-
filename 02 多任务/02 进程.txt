exe就是一个二进制文件，二进制文件就是操作系统可以直接执行的文件


程序与进程的小差别(通俗理解 )：
程序：代码还没运行之前都是静态的，称为程序
进程：让代码（程序）运行的就是进程

进程是一个拥有资源的地方，比如拥有了内存，网卡，显卡等等
进程是一个资源分配的地方 

程序只有一个，但可以有多个进程（比如，应用多开）

进程：一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元，不仅可以通过多线程完成多任务，进程也是可以的

工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态

就绪态：运行的条件都已经慢去，正在等在cpu运行
执行态：cpu正在执行其功能
等待态：等待某些条件满足，例如一个程序sleep了，此时就是等待态



进程的创建---multiprocessing

from multiprocessing import Process
import time

def run_proc():
	'''子进程需要执行的代码'''
	while True：
		print('---2---')
		time.sleep(1)

if __name__ == '__main__':
	p = Process(target=run_proc)
	p.start()
	while True:
		print('---1---')
		time.sleep(1)
说明：创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start（）方法启动



进程pid
from multiprocessing import Process
import os
import time

def run_proc():
	'''子进程需要执行的代码'''
	print('子进程运行中，pid=%d...' % ps.getpid())	# os.getpid获取当前进程的进程号
	print('子进程将要结束...')

if __name__ == '__main__':
	print('父进程pid: %d ' % os.getpid())
	p = Process(target=run_proc)
	p.start()


注意：主进程有的（包括代码和资源），子进程都有
线程和进程都可以实现多任务，但是进程耗费的资源比较大，容易造成资源的浪费
进程数不是越多越好，得考虑硬件资源

进程占用资源大，线程占用资源少

在一定范围内，进程数越多越好，但到达一定的数量后，效率就不见得更高了


 Process语法结构如下：
	Process([group[,target[,name[,args[,kwargs]]]]])	 
	target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码
	args：给target指定的函数传递的参数，以语族的方式传递
	kwargs：给target指定的函数传递命名参数
	name：给进程设定一个名字，可以不设定
	group：指定进程组，大多数情况下用不到


Process创建的实例对象的常用方法：
	start():启动进程实例（创建子进程）
	is_alive():判断进程子进程是否还或者
	join([timeout])：是否等待子进程执行结束，或等待多少秒
	terminate():不管任务是否完成，立即终止子进程



可以用以下两种方式理解：
不共享代码：
一般情况下，创建一个进程就是将代码和资源复制一遍，子线程在复制的代码的指定位置执行（一个进程复制一遍，因此容易造成资源的浪费）
一般情况下，子进程更改的是数据，一般不会更改代码（如a+=1，更改的就是数据）

共享代码：
所有进程共用一份代码，只是有很多个箭头在执行不同的部分


总而言之，只要能共享的就共享，实在不能共享的接下来操作系统就给你复制一份

写时拷贝（理解）：如果子进程不需要修改代码时，共用一份代码，如若需要用特殊手段修改代码，那么就给该进程复制一份代码供其修改


注意：线程没有那么复杂，共享就可以了，而进程还要考虑以上问题
进程占用的资源大，而线程占用的资源少



进程、线程对比
功能：
	进程：能够完成多任务，比如在一台电脑上能够同时运行多个前期
	线程：能够完成多任务，比如一个QQ中的多个聊天窗口
把进程理解为应用多开，而在进程里面实现多任务就是线程
进程先有，才有的线程
进程仅仅只是个资源分配的单位，而线程拿着进程分配的资源去做


代码-->进程

一个进程里面最少有一个主线程
如何理解以上这句话：
如果是用线程的话，那么一定会有个主线程
如果是进程的话，那么进程每次拷贝的代码上都会有个箭头在要执行代码附近



多线程能实现多任务指的是：在一个进程资源里有多个箭头在执行代码

而多进程实现多任务指的是：又开辟了一个资源，在这个资源里有一个箭头执行代码


定义的不同：
进程是系统进行资源分配的调度的一个独立单位

线程是进程的一个实体，是cpu调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有
一点在运行中必不可少的资源（如：程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源


区别
一个程序至少有一个进程，一个进程至少有一个线程
线程的划分小于进程（资源比进程少），使得多线程程序的并发行性
进程在执行过程中拥有独立的单元空间，而多线程共享内存，从而极大的提高了程序的运行效率
线程不能够独立执行，必须依存在进程中
可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人


优缺点
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护，而进程正相反




进程间通信---Queue
Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信

1、Queue的使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，首先用一个小实例来演示以下Queue的工作原理：

from multiprocessing import Queue
q = Queue(3)	# 初始化一个Queue对象，最多可接收三条put消息
q.put('消息1')
q.put('消息2')
print(q.full())	# False
q.put('消息3')
print(q.full())	# True

# 因为消息列队已满，下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个try会立刻抛出异常
try：
	q.put('消息4'，True,2)
except:
	print('消息队列已满，现有消息数量：%s' % q.qsize())

try:
	q.put_nowait('消息4')
except：
	print('消息列队已满，现有消息数量：%s' % q.qsize())

# 推荐的方式，先判断消息列队是否已满，再写入
if not q.full():
	q.put_nowait('消息4')

# 读取消息时，先判断消息列队是否为空，再读取
if not q.empty():
	for i in range(q.qsize()):
		print(q.get_nowait())



get_nowait()--->该方法如果队列里有内容，那么显示，如果没有，那么通过抛出异常提示
get（）--->该方法如果队列里有内容，那么显示出来，如果没有，则闪烁光标，一直停在那里


put和put_nowait同理

full()-->该方法用于判断队列是否满
empty()-->该方法用于判断队列是否空


Queue()--->括号内的参数为队列长度，如果不填，那么默认最大 ，计算机会自己根据硬件计算最大值

Queue只能用在同一个程序的多个进程




进程池Pool
当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态生成多个进程，但如果上百甚至上千个目标，手动的去创建进程的工作量巨大，此时可以用到multiprocessing模块提供的Pool方法

初始化Pool时，可以指定一个最大进程数，当所有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；
但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程执行新的任务

from multiprocessing import Pool
import os,time,random

def worker(msg):
	t_start = time.time()
	print('%s开始执行，进程号为%d' % (msg,os.getpid()))
	# random.random()随机生成0・1之间的浮点数
	time.sleep(random.random()*2)
	t_stop = time.time()
	print(msg, '执行完毕，耗时%0.2f' % (t_stop - t_start))

po = Pool(3)	# 定义一个进程池，最大进程数为3
for i in range(0,10):
	# Pool().apply_async(要调用的目标，(传递给目标的参数元组，))
	# 每次循环将会用空闲出来的子进程去调用目标
	po.apply_async(worker,(i,))

print('---start---')
po.close()		# 关闭进程池，关闭后po不再接收新的请求
po.join()		# 等待po中所有子进程执行完成，必须放在close语句之后
print('---end---')



注意：join()--->该方法用于等待进程池中所有的子进程执行完成，必须放在close语句之后

注意：在使用进程池中出现错误，不会显示，得注意  

如果多任务是用进程池来做的，并且用到了进程间的通信
那么就要用 
from multiprocessing import Manager,Pool
po = Manager().Queue()  
以上两行代码来创建队列
用该方法创建的Queue就可以传递到进程池中的进程去执行
/r表示将光标的位置回退到本行开头的位置


理解耦合度和解耦（百度）






































