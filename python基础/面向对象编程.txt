面向对象的三个特点：1.封装：根据职责将属性和方法封装到一个类中
		  2.继承：实现代码的重用，相同的代码不需要重复的编写
		  3.多态：不同的对象调用相同的方法，产生不用的执行结果，增加代码的灵活度

在面向对象编程中，可以直接在对象后面用‘.’加属性来添加属性
如给对象cat添加一个name属性----->cat.name='Tom'（不推荐使用-----如果在运行时，没有找到属性，程序会报错）
属性应该封装在类的内部

――――――――封装

初始化对象的方法：  __init__(注意，两条下划线)
使用类名（）创建对象的时候，会自动调用初始化方法  __init__
__init__方法是专门用来定义一个类具有哪些属性的方法！
self.name = name
等号左边的name是属性，等号右边的name是形参

身份运算符用于比较两个对象的内存地址是否一致-----是否是对同一对象的引用（即判断两个的对象内存地址是否相同）
	在python中针对None比较时，建议使用is判断
	如：if self.gun==None 与 if self.gun is None 结果相同，建议使用后者
	（is用于判断两个变量引用的是否为同一个；==用于判断引用变量的值是否相等）
私有属性/私有方法：
	应用场景：
		在实际的开发中，对象的某些属性或方法可能只希望在对象的内部被使用，而不希望在外部被访问到
		私有属性（方法）就是对象不希望公开的属性（方法）

	定义方式：
		在定义属性和方法时，在属性名或方法名前增加两个下划线，定义的就是私有属性或方法

			例子：class Women：
				
				def __init__(self,name):
					self.name=name
					self.__age=18	#定义私有属性

				def __secret（self）:		#定义一个私有方法
					print('%s 的年龄为 %d' %（self.name,self.__age）)

			xiaofang=Women（’小芳‘）	#定义一个对象
			print（xiaofang.__age）	#这样执行是会报错的，私有属性，在外界不能够被直接访问
			xiaofang.__secret()		#这样执行也是会报错的，私有方法，同样在外界不能够被直接访问

在python中没有真正意义上的私有（建议不使用以下方法来访问私有属性），成为伪私有属性或伪私有方法

	在给的属性、方法命名时，实际是对名称做了一些特殊处理，使得外界无法访问到
	处理方法：在名称前面加上  _类名=>_类名__名称（前面两个只有一个下划线，最后一个有两个）
	
		为了让以上的私有属性（方法）输出，可以用以下方法：
			print（xiaofang._Women__age）
			xiaofang._Women__secret()
	建议不要在公共部分访问私有属性


――――――――继承

	继承的概念：子类拥有父类的所有属性和方法
	继承的语法：	class 类名（父类名）：
				pass

	继承的专业术语：
		以Dog和Animal为例
			Dog类是Animal的子类，Animal是Dog的父类，Dog类从Animal类继承
			Dog类是Animal的派生类，Animal是Dog的基类，Dog类从Animal类派生

	方法重写：
		应用场景：当父类的方法实现不能满足子类需求时，可以对方法进行重写
		实现方法：就相当于在子类中定义了一个和父类同名的方法并且实现
		重写之后，在运行时，只会调用子类中重写的方法，而不再会调用父类的封装的方法

	对父类方法进行扩展：
		如果在开发中，子类的实现方法实现中包含父类方法的实现
		
		1、在子类中重写父类的方法
		2、在需要的位置使用super（）.父类方法   来调用父类方法的执行
		3、代码的其他位置针对子类的需求，编写子类特有的代码实现

	关于super（）
		在python中super是一个特殊的类
		super（）就是使用super类创建出来的对象
		最常见的场景就是在重写父类的方法时，调用在父类中封装的方法实现

	父类的私有属性和私有方法
		子类对象不能在不能在自己的方法内部，直接访问父类的私有属性或私有方法
		子类对象可以通过父类的公有方法间接访问到私有属性或私有方法

		私有属性、方法是对象的隐私，不对外公开，外界以及子类都不能直接访问
		私有属性、方法通常用于做一些内部的事情


	多继承：
		语法   class 类名（父类名1，父类名2.....	）：
			pass

		
	注意事项:
		如果不同父类中存在同名的方法，子类对象在调用方法时，会调用哪一个父类中的方法呢？

		开发时，应该尽量避免这种容易产生混淆的情况！如果父类之间存在同名的属性或方法，应该尽量避免使用多继承

		可以通过print（类名.__mro__）来查看继承顺序，默认最先是自己，然后是父类的输入顺序，从左往右，最后是object类
	
		但为了让自己的代码尽量的直观，尽量的可读，别出现误解，因此，再有属性或者方法重名是，尽量不要使用多继承


	新式类与旧式（经典）类（科普）：
		
		object是python为所有对象提供的基类，提供有一些内置的属性和方法，可以使用dir函数查看
	新式类：以object为基类的的类，推荐使用
	旧式类：不以object为基类的类，不推荐使用

	在python3.x中定义类时，如果没有指定父类，会默认使用object为该类的基类-----python3.x中定义的类都是基类
	在python2.x中定义类时，如果没有指定父类，则不会以object为基类
	新式类和旧式类在多继承时，会影响到方法的搜索顺序

	为了保证编写的代码能够同时在python2.x和python3.x运行，今后定义类时，如果没有父类，建议统一继承object


――――――――多态
		
		多态 不同的子类对象调用相同的父类方法，产生不同的执行结果
			多态可以增加代码的灵活度
			以继承和重写父类方法为前提
			是调用方法的技巧，不会影响到类的内部设计
	

创建出来的对象叫做类的实例
创建对象的动作叫做实例化
对象的属性叫做实例属性
对象在调动的方法叫做实例方法


每一个对象都有自己独立的内存空间，保存各自不同的属性
多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部

---python中一切皆对象

在程序运行中，类同样会被加载到内存
在python中，类是一个特殊的对象----类对象
在程序运行中，类对象在内存中只有一份，使用一个类可以创建出很多个对象实例（模板只需要一个就可以创建出很多个具体的对象）
除了封装实例的属性和方法外，类对象还可以拥有自己的属性和方法

通过类名的方式可以访问类的属性或者调用类的方法


类属性就是给类对象中定义的属性
通常用来记录与这个类相关的特征
类属性不会用于记录具体对象的特征

以下为例子：
class Tool（object）：
	#使用赋值语句，定义类的属性，记录创建工具的总数
	count=0

	def __init__（self，name）：
		self.name=name
		#针对类属性做一件计数+1
		count += 1

#创建工具对象
tool1=Tool（‘斧头’）
tool2=Tool（‘榔头’）
tool3=Tool（‘铁球’）

以上为例子

可以通过print（Tool.count）来查看类属性
也可以通过print（tool1.count）来查看类属性

因此，要访问类属性的两种形式
1、类名.类属性
2、对象.类属性（不推荐）

在python中属性的获取存在一个向上查找机制
1.首先在对象内部查找对象属性
2.若没找到就会向上寻找类属性


注意
如果使用   对象.类属性 = 值    赋值语句，只会给对象添加一个属性，而不会影响到类属性的值


--------类方法和静态方法

-----类方法（注意：还未理解）

类属性就是针对类对象定义的属性
	使用赋值语句是 在class关键词下方可以定义类属性
	类属性就是用以记录与这个类相关的特征
类方法就是针对类对象定义的方法
	在类方法内部可以直接访问类属性或者调用其他的类方法


语法如下
@classmethod
def 类方法名（cls）：	
	pass

类方法需要用修饰器@classmethod来标识，告诉解释器这是一个类方法

类方法的第一个参数应该是cls
	由哪一个类调用的方法，方法内的cls就是哪一类的引用
	这个参数和实例方法的第一个参数self类似
	提示：使用其他名称也可以，不过习惯使用cls
通过类名调用类方法，调用方法时，不需要传递cls参数

在方法内部
	可以通过 cls.  访问类的属性
	也可以通过  cls.   调用其他的类方法

-----静态方法

在开发时，如果需要在类中封装一个方法，这个方法：
	既不需要访问实例属性或者调用实例方法
	也不需要访问类属性或者调用类的类方法
这个时候，可以把这个方法封装成一个静态方法

语法如下：
@statimethod
def 静态方法名（）：
	pass


静态方法需要用修饰器 @staticmethod  来标识，告诉解释器这是一个静态方法
通过  类名.    调用静态方法（可以不需要创建对象）
	

小结：
	1、实例方法 --方法内部需要访问实例属性
		实例方法内部可以使用   类名.   访问类属性
	2、类方法  --方法内部只需要访问类属性
	3、静态方法 --方法内部，不需要访问实例属性和类属性

提问：
	如果方法内部即需要访问实例属性，又需要访问类属性，应该定义成什么方法？
答案：
	应该定义实例方法
	因为，类只有一个，在实例方法内部可以使用   类名.     访问类属性



---------单例

1、单例的设计模式
	设计模式
	（1）设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对某一特定问题的成熟的解决方案
	（2）使用设计模式是为了可重用的代码、让代码更容易被他人理解、保证代码的可靠性

	单例设计模式
	（1）目的---让类的创建的对象，在系统中只有唯一的一个实例
	（2）每一次执行  类名（）   返回的对象，内存地址都是相同的

2、__new__方法
	使用  类名（）  创建对象是，python的解释器首先会调用__new__方法为对象分配空间

	__new__是一个有object基类提供的内置的静态方法，主要作用用两个：
		1）在内存中为对象分配空间
		2）返回对象的引用


	python的解释器获取 对象的引用后，将引用作为第一个参数，传递给__init__方法

	重写__new__方法的代码非常固定
		重写__new__方法一定要  return.super().__new__(cls)
		否则python的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法
		注意：__new__是一个静态方法，在调用时需要主动传递cls参数	



